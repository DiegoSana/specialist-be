generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                      String                   @id @default(uuid())
  email                   String                   @unique
  password                String? // Optional for social login users
  firstName               String
  lastName                String
  phone                   String?
  profilePictureUrl       String?
  isAdmin                 Boolean                  @default(false)
  status                  UserStatus               @default(PENDING)
  // Social login providers
  googleId                String?                  @unique
  facebookId              String?                  @unique
  authProvider            AuthProvider             @default(LOCAL)
  createdAt               DateTime                 @default(now())
  updatedAt               DateTime                 @updatedAt
  contacts                Contact[]                @relation("FromUser")
  contactsReceived        Contact[]                @relation("ToUser")
  client                  Client?
  professional            Professional?
  company                 Company?
  requests                Request[]                @relation("Client")
  reviewsGiven            Review[]                 @relation("Reviewer")
  reviewsModerated        Review[]                 @relation("Moderator")
  inAppNotifications      InAppNotification[]
  notificationPreferences NotificationPreferences?
  notifications           Notification[]

  @@map("users")
}

model Client {
  id                   String   @id @default(uuid())
  userId               String   @unique
  preferences          Json?
  savedProfessionals   String[] @default([])
  searchHistory        Json?
  notificationSettings Json?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("clients")
}

model Trade {
  id            String              @id @default(uuid())
  name          String              @unique
  category      String?
  description   String?
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  professionals ProfessionalTrade[]
  companies     CompanyTrade[]
  requests      Request[]

  @@map("trades")
}

// ServiceProvider is the abstract base for both Professional and Company
// This allows Request and Review to work with either type
model ServiceProvider {
  id            String       @id @default(uuid())
  type          ProviderType
  averageRating Float        @default(0)
  totalReviews  Int          @default(0)
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  professional Professional?
  company      Company?
  requests     Request[]          @relation("Provider")
  reviews      Review[]
  interests    RequestInterest[]

  @@map("service_providers")
}

model Professional {
  id                String             @id @default(uuid())
  userId            String             @unique
  serviceProviderId String             @unique
  description       String?
  experienceYears   Int?
  status            ProfessionalStatus @default(PENDING_VERIFICATION)
  zone              String?
  city              String             @default("Bariloche")
  address           String?
  whatsapp          String?
  website           String?
  profileImage      String?
  gallery           String[]
  active            Boolean            @default(true)
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt

  trades          ProfessionalTrade[]
  user            User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  serviceProvider ServiceProvider     @relation(fields: [serviceProviderId], references: [id], onDelete: Cascade)

  @@map("professionals")
}

model ProfessionalTrade {
  id             String       @id @default(uuid())
  professionalId String
  tradeId        String
  isPrimary      Boolean      @default(false)
  createdAt      DateTime     @default(now())
  professional   Professional @relation(fields: [professionalId], references: [id], onDelete: Cascade)
  trade          Trade        @relation(fields: [tradeId], references: [id], onDelete: Cascade)

  @@unique([professionalId, tradeId])
  @@map("professional_trades")
}

// Company profile for businesses (constructoras, etc.)
model Company {
  id                String @id @default(uuid())
  userId            String @unique
  serviceProviderId String @unique

  // Company info
  companyName   String
  legalName     String?
  taxId         String? // CUIT/RUT
  description   String?
  foundedYear   Int?
  employeeCount String? // "1-5", "6-20", "21-50", "50+"

  // Contact
  website String?
  phone   String?
  email   String?

  // Location
  address String?
  city    String  @default("Bariloche")
  zone    String?

  // Status
  status       CompanyStatus @default(PENDING_VERIFICATION)
  profileImage String?
  gallery      String[]
  active       Boolean       @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  serviceProvider ServiceProvider @relation(fields: [serviceProviderId], references: [id], onDelete: Cascade)
  trades          CompanyTrade[]

  @@map("companies")
}

model CompanyTrade {
  id        String   @id @default(uuid())
  companyId String
  tradeId   String
  isPrimary Boolean  @default(false)
  createdAt DateTime @default(now())
  company   Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  trade     Trade    @relation(fields: [tradeId], references: [id], onDelete: Cascade)

  @@unique([companyId, tradeId])
  @@map("company_trades")
}

enum CompanyStatus {
  PENDING_VERIFICATION
  VERIFIED
  REJECTED
}

model Request {
  id                  String        @id @default(uuid())
  clientId            String
  providerId          String? // ServiceProvider ID (Professional or Company)
  tradeId             String? // Trade for public requests
  isPublic            Boolean       @default(false)
  title               String        @default("")
  description         String
  address             String?
  availability        String?
  photos              String[]      @default([])
  status              RequestStatus @default(PENDING)
  quoteAmount         Float?
  quoteNotes          String?
  // Client rating by provider (after work is done)
  clientRating        Int?
  clientRatingComment String?
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt

  client    User              @relation("Client", fields: [clientId], references: [id], onDelete: Cascade)
  provider  ServiceProvider?  @relation("Provider", fields: [providerId], references: [id], onDelete: Cascade)
  trade     Trade?            @relation(fields: [tradeId], references: [id])
  review    Review?
  interests RequestInterest[]

  @@map("requests")
}

model RequestInterest {
  id                String          @id @default(uuid())
  requestId         String
  serviceProviderId String          // Can be Professional or Company
  message           String?         // Optional message from provider
  createdAt         DateTime        @default(now())
  request           Request         @relation(fields: [requestId], references: [id], onDelete: Cascade)
  serviceProvider   ServiceProvider @relation(fields: [serviceProviderId], references: [id], onDelete: Cascade)

  @@unique([requestId, serviceProviderId])
  @@map("request_interests")
}

model Review {
  id                String       @id @default(uuid())
  reviewerId        String
  serviceProviderId String // ServiceProvider being reviewed
  requestId         String       @unique // Review is always tied to a request
  rating            Int
  comment           String?
  status            ReviewStatus @default(PENDING)
  moderatedAt       DateTime?
  moderatedBy       String?
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt

  serviceProvider ServiceProvider @relation(fields: [serviceProviderId], references: [id], onDelete: Cascade)
  request         Request         @relation(fields: [requestId], references: [id])
  reviewer        User            @relation("Reviewer", fields: [reviewerId], references: [id], onDelete: Cascade)
  moderator       User?           @relation("Moderator", fields: [moderatedBy], references: [id])

  @@map("reviews")
}

enum ReviewStatus {
  PENDING
  APPROVED
  REJECTED
}

model Contact {
  id          String   @id @default(uuid())
  fromUserId  String
  toUserId    String
  contactType String   @default("whatsapp")
  message     String?
  createdAt   DateTime @default(now())
  fromUser    User     @relation("FromUser", fields: [fromUserId], references: [id], onDelete: Cascade)
  toUser      User     @relation("ToUser", fields: [toUserId], references: [id], onDelete: Cascade)

  @@map("contacts")
}

model InAppNotification {
  id        String    @id @default(uuid())
  userId    String
  type      String
  title     String
  body      String?
  data      Json?
  readAt    DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@map("in_app_notifications")
}

enum ExternalNotificationChannel {
  EMAIL
  WHATSAPP
}

enum NotificationChannel {
  IN_APP
  EMAIL
  WHATSAPP
}

enum NotificationDeliveryStatus {
  PENDING
  SENT
  FAILED
  SKIPPED
}

model Notification {
  id             String   @id @default(uuid())
  userId         String
  type           String
  title          String
  body           String?
  data           Json?
  idempotencyKey String?  @unique
  createdAt      DateTime @default(now())

  user       User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  deliveries NotificationDelivery[]

  @@index([userId, createdAt])
  @@map("notifications")
}

model NotificationDelivery {
  id                String                     @id @default(uuid())
  notificationId    String
  channel           NotificationChannel
  status            NotificationDeliveryStatus @default(PENDING)
  providerMessageId String?
  errorCode         String?
  errorMessage      String?
  attemptCount      Int                        @default(0)
  lastAttemptAt     DateTime?
  nextAttemptAt     DateTime?
  sentAt            DateTime?
  readAt            DateTime?
  createdAt         DateTime                   @default(now())
  updatedAt         DateTime                   @updatedAt

  notification Notification @relation(fields: [notificationId], references: [id], onDelete: Cascade)

  @@unique([notificationId, channel])
  @@index([channel, status, nextAttemptAt])
  @@map("notification_deliveries")
}

model NotificationPreferences {
  id                       String                      @id @default(uuid())
  userId                   String                      @unique
  inAppEnabled             Boolean                     @default(true)
  externalEnabled          Boolean                     @default(true)
  preferredExternalChannel ExternalNotificationChannel @default(EMAIL)
  /// Per-type overrides (optional).
  /// Example:
  /// {
  ///   "REQUEST_STATUS_CHANGED": { "externalEnabled": false },
  ///   "REQUEST_INTEREST_EXPRESSED": { "preferredExternalChannel": "WHATSAPP" }
  /// }
  overrides                Json?
  createdAt                DateTime                    @default(now())
  updatedAt                DateTime                    @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notification_preferences")
}

enum UserRole {
  ADMIN
}

enum UserStatus {
  PENDING
  ACTIVE
  SUSPENDED
  BANNED
}

enum ProfessionalStatus {
  PENDING_VERIFICATION
  VERIFIED
  REJECTED
}

enum RequestStatus {
  PENDING
  ACCEPTED
  IN_PROGRESS
  DONE
  CANCELLED
}

enum AuthProvider {
  LOCAL
  GOOGLE
  FACEBOOK
}

enum ProviderType {
  PROFESSIONAL
  COMPANY
}
